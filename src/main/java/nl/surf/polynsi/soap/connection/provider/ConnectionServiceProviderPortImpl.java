/**
 * Please modify this class to meet your needs
 * This class is not complete
 */

package nl.surf.polynsi.soap.connection.provider;

import com.google.protobuf.util.Timestamps;
import io.grpc.StatusRuntimeException;
import nl.surf.polynsi.ConverterException;
import nl.surf.polynsi.soap.connection.types.*;
import nl.surf.polynsi.soap.framework.headers.CommonHeaderType;
import nl.surf.polynsi.soap.framework.types.ServiceExceptionType;
import nl.surf.polynsi.soap.services.p2p.P2PServiceBaseType;
import nl.surf.polynsi.soap.services.types.OrderedStpType;
import nl.surf.polynsi.soap.services.types.TypeValueType;
import org.apache.cxf.jaxb.JAXBDataBinding;
import org.ogf.nsi.grpc.connection.common.GenericAcknowledgment;
import org.ogf.nsi.grpc.connection.common.Header;
import org.ogf.nsi.grpc.connection.common.Schedule;
import org.ogf.nsi.grpc.connection.provider.*;
import org.ogf.nsi.grpc.connection.requester.QueryConfirmedRequest;
import org.ogf.nsi.grpc.connection.requester.QueryNotificationConfirmedRequest;
import org.ogf.nsi.grpc.connection.requester.QueryResultConfirmedRequest;
import org.ogf.nsi.grpc.services.Directionality;
import org.ogf.nsi.grpc.services.PointToPointService;
import org.springframework.beans.factory.annotation.Autowired;

import jakarta.annotation.Generated;
import jakarta.annotation.Resource;
import jakarta.xml.bind.JAXBElement;
import jakarta.xml.bind.JAXBException;
import javax.xml.namespace.QName;
import jakarta.xml.ws.WebServiceContext;
import java.text.ParseException;
import java.time.OffsetDateTime;
import java.time.format.DateTimeFormatter;
import java.util.ArrayList;
import java.util.Comparator;
import java.util.List;
import java.util.logging.Logger;
import java.util.stream.Collectors;

import static com.google.protobuf.util.Timestamps.EPOCH;
import static nl.surf.polynsi.Converter.toProtobuf;
import static nl.surf.polynsi.Converter.toSoap;

/**
 * This class was generated by Apache CXF 3.3.5
 * 2020-04-27T16:21:07.875+02:00
 * Generated source version: 3.3.5
 */


@org.apache.cxf.feature.Features (features = {"nl.surf.polynsi.soap.connection.provider.PrettyLoggingFeature"})
@jakarta.jws.WebService(serviceName = "ConnectionServiceProvider",
        portName = "ConnectionServiceProviderPort",
        targetNamespace = "http://schemas.ogf.org/nsi/2013/12/connection/provider",
        wsdlLocation = "wsdl/connection/ogf_nsi_connection_provider_v2_0.wsdl",
        endpointInterface = "nl.surf.polynsi.soap.connection.provider.ConnectionProviderPort")
public class ConnectionServiceProviderPortImpl implements ConnectionProviderPort {

    @Generated(value = "org.apache.cxf.tools.wsdlto.WSDLToJava", date = "2020-04-27T16:21:07.875+02:00")
    private static final Logger LOG = Logger.getLogger(ConnectionServiceProviderPortImpl.class.getName());

    @Autowired
    private ConnectionProviderGrpc.ConnectionProviderBlockingStub connectionProviderStub;

    @Resource
    private  WebServiceContext webServiceContext;

    private void addHeaders(CommonHeaderType soapHeader) {
            // clear any extension from header, fix for 'PathTraceType is not known to this context' error
        soapHeader.getAny().clear();
        /*
            Add nsiHeader to automatically generate ServiceException and Error messages
            using a generic way of adding SOAP headers to a message. This probably can also be implemented
            with a CXF SoapHeaderInterceptor that extends AbstractSoapInterceptor.
         */
        try {
            List<org.apache.cxf.headers.Header> headers = new ArrayList<>();
            soapHeader.setReplyTo(null);
            org.apache.cxf.headers.Header nsiHeader = new org.apache.cxf.headers.Header(
                    new QName("http://schemas.ogf.org/nsi/2013/12/framework/headers", "nsiHeader"),
                    soapHeader,
                    new JAXBDataBinding(CommonHeaderType.class)
            );
            headers.add(nsiHeader);
            webServiceContext.getMessageContext().put(org.apache.cxf.headers.Header.HEADER_LIST, headers);
        }  catch (JAXBException ex) {
            LOG.warning(ex.toString());
        }
    }

    private ServiceExceptionType newServiceException(String providerNSA, String connectionId) {
        var objectFactory = new nl.surf.polynsi.soap.framework.types.ObjectFactory();
        ServiceExceptionType serviceException = objectFactory.createServiceExceptionType();
        serviceException.setNsaId(providerNSA);
        serviceException.setConnectionId(connectionId);
        return serviceException;
    }

    private ServiceExceptionType notImplementedServiceException(String providerNSA, String feature) {
        var serviceException = newServiceException(providerNSA, null);
        serviceException.setErrorId("00103");
        serviceException.setText(
                "NOT_IMPLEMENTED: Requested feature has not been implemented (%s)".formatted(feature)
        );
        return serviceException;
    }

    private GenericErrorType notImplementedError (String providerNSA, String feature) {
        var objectFactory = new nl.surf.polynsi.soap.connection.types.ObjectFactory();
        GenericErrorType error = objectFactory.createGenericErrorType();
        error.setServiceException(notImplementedServiceException(providerNSA, feature));
        return error;
    }

    private ServiceExceptionType genericInternalServiceException(String providerNSA, String connectionId, String text) {
        var serviceException = newServiceException(providerNSA, connectionId);
        serviceException.setErrorId("00500");
        serviceException.setText(
                "GENERIC_INTERNAL_ERROR: An internal error has caused a message processing failure (%s)".formatted(text)
        );
        return serviceException;
    }

    private GenericErrorType genericInternalError (String providerNSA, String connectionId, String text) {
        var objectFactory = new nl.surf.polynsi.soap.connection.types.ObjectFactory();
        GenericErrorType error = objectFactory.createGenericErrorType();
        error.setServiceException(genericInternalServiceException(providerNSA, connectionId, text));
        return error;
    }
    
    @Generated(value = "org.apache.cxf.tools.wsdlto.WSDLToJava", date = "2020-04-27T16:21:07.875+02:00")
    public void provision(String connectionId, jakarta.xml.ws.Holder<CommonHeaderType> soapHeader) throws ServiceException {
        LOG.info("SOAP->gRPC provision from %s".formatted(soapHeader.value.getRequesterNSA()));
        LOG.fine("connection ID %s".formatted(connectionId));
        try {
            Header pbHeader = toProtobuf(soapHeader.value);
            GenericRequest pbProvisionRequest = GenericRequest.newBuilder().setHeader(pbHeader)
                    .setConnectionId(connectionId).build();

            LOG.finer("Built protobuf message `GenericRequest`:\n" + pbProvisionRequest);
            GenericAcknowledgment pbProvisionResponse = connectionProviderStub
                    .provision(pbProvisionRequest);
            // check the protobuf ProvisionResponse and either return a SOAP ServiceException or the generic Ack
            if (pbProvisionResponse.hasServiceException()) {
                addHeaders(soapHeader.value);
                throw new ServiceException(
                        pbProvisionResponse.getServiceException().getText(),
                        toSoap(pbProvisionResponse.getServiceException())
                );
            }
        } catch (ConverterException | StatusRuntimeException ex) {
            addHeaders(soapHeader.value);
            throw new ServiceException(
                    ex.toString(),
                    genericInternalServiceException(soapHeader.value.getProviderNSA(), connectionId, ex.toString())
            );
        }
    }

    @Generated(value = "org.apache.cxf.tools.wsdlto.WSDLToJava", date = "2020-04-27T16:21:07.875+02:00")
    public QuerySummaryConfirmedType querySummarySync(QueryType querySummarySync,
                                                      jakarta.xml.ws.Holder<CommonHeaderType> soapHeader) throws Error {
        LOG.info("SOAP->gRPC querySummarySync from %s".formatted(soapHeader.value.getRequesterNSA()));
        for (String connectionId : querySummarySync.getConnectionId())
            LOG.fine("connection ID %s".formatted(connectionId));
        for (String globalReservationId : querySummarySync.getGlobalReservationId())
            LOG.fine("global reservation ID %s".formatted(globalReservationId));
        if (querySummarySync.getIfModifiedSince() != null)
            LOG.fine("if modified since %s".formatted(querySummarySync.getIfModifiedSince().format(DateTimeFormatter.ISO_OFFSET_DATE_TIME)));
        try {
            Header pbHeader = toProtobuf(soapHeader.value);
            QueryRequest.Builder pbQueryReguestBuilder = QueryRequest.newBuilder();
            pbQueryReguestBuilder.setHeader(pbHeader);
            if (querySummarySync.getIfModifiedSince() != null) {
                pbQueryReguestBuilder.setIfModifiedSince(Timestamps.parse(
                        querySummarySync.getIfModifiedSince().format(DateTimeFormatter.ISO_OFFSET_DATE_TIME)
                ));
            }
            pbQueryReguestBuilder.addAllConnectionId(querySummarySync.getConnectionId());
            pbQueryReguestBuilder.addAllGlobalReservationId(querySummarySync.getGlobalReservationId());
            LOG.finer("Built protobuf message `QueryRequest`:\n" + pbQueryReguestBuilder.build());
            // QuerySummarySync returns a QuerySummaryConfirmedRequest bypassing the associated Response messages
            QueryConfirmedRequest pbQueryConfirmedRequest = connectionProviderStub
                    .querySummarySync(pbQueryReguestBuilder.build());
            // the pbQueryConfirmedRequest does not have a service exception field,
            // it is assumed that the query operations does not cause exceptions in SuPA

            var objectFactory = new nl.surf.polynsi.soap.connection.types.ObjectFactory();
            QuerySummaryConfirmedType soapQuerySummaryConfirmed = objectFactory.createQuerySummaryConfirmedType();
            for (QuerySummaryResultType soapQuerySummaryResult : toSoap(pbQueryConfirmedRequest))
                soapQuerySummaryConfirmed.getReservation().add(soapQuerySummaryResult);
            OffsetDateTime lastModified = null;
            if (!pbQueryConfirmedRequest.getLastModified().equals(EPOCH)) {
                lastModified = toSoap(pbQueryConfirmedRequest.getLastModified());
            }
            soapQuerySummaryConfirmed.setLastModified(lastModified);
            return soapQuerySummaryConfirmed;
        } catch (ConverterException | ParseException | StatusRuntimeException ex) {
            addHeaders(soapHeader.value);
            throw new Error(
                    ex.toString(),
                    genericInternalError(soapHeader.value.getProviderNSA(), null, ex.toString())
            );
        }
    }

    @Generated(value = "org.apache.cxf.tools.wsdlto.WSDLToJava", date = "2020-04-27T16:21:07.875+02:00")
    public GenericAcknowledgmentType queryRecursive(QueryType queryRecursive, jakarta.xml.ws.Holder<CommonHeaderType> soapHeader) throws ServiceException {
        LOG.info("SOAP->gRPC queryRecursive from %s".formatted(soapHeader.value.getRequesterNSA()));
        for (String connectionId : queryRecursive.getConnectionId())
            LOG.fine("connection ID %s".formatted(connectionId));
        for (String globalReservationId : queryRecursive.getGlobalReservationId())
            LOG.fine("global reservation ID %s".formatted(globalReservationId));
        if (queryRecursive.getIfModifiedSince() != null)
            LOG.fine("if modified since %s".formatted(queryRecursive.getIfModifiedSince().format(DateTimeFormatter.ISO_OFFSET_DATE_TIME)));
        try {
            Header pbHeader = toProtobuf(soapHeader.value);
            QueryRequest.Builder pbQueryReguestBuilder = QueryRequest.newBuilder();
            pbQueryReguestBuilder.setHeader(pbHeader);
            if (queryRecursive.getIfModifiedSince() != null) {
                pbQueryReguestBuilder.setIfModifiedSince(Timestamps.parse(queryRecursive.getIfModifiedSince().format(DateTimeFormatter.ISO_OFFSET_DATE_TIME)));
            }
            pbQueryReguestBuilder.addAllConnectionId(queryRecursive.getConnectionId());
            pbQueryReguestBuilder.addAllGlobalReservationId(queryRecursive.getGlobalReservationId());
            LOG.finer("Built protobuf message `QueryRequest`:\n" + pbQueryReguestBuilder.build());
            GenericAcknowledgment pbQueryResponse = connectionProviderStub
                    .queryRecursive(pbQueryReguestBuilder.build());
            // check the protobuf QueryResponse and either return a SOAP ServiceException or the generic Ack
            if (pbQueryResponse.hasServiceException()) {
                addHeaders(soapHeader.value);
                throw new ServiceException(
                        pbQueryResponse.getServiceException().getText(),
                        toSoap(pbQueryResponse.getServiceException())
                );
            }
            var objectFactory = new nl.surf.polynsi.soap.connection.types.ObjectFactory();
            return objectFactory.createGenericAcknowledgmentType();
        } catch (ConverterException | ParseException | StatusRuntimeException ex) {
            addHeaders(soapHeader.value);
            throw new ServiceException(
                    ex.toString(),
                    genericInternalServiceException(soapHeader.value.getProviderNSA(), null, ex.toString())
            );
        }
    }

    public void reserveCommit(String connectionId, jakarta.xml.ws.Holder<CommonHeaderType> soapHeader) throws ServiceException {
        LOG.info("SOAP->gRPC reserveCommit from %s".formatted(soapHeader.value.getRequesterNSA()));
        LOG.fine("connection ID %s".formatted(connectionId));
        try {
            Header pbHeader = toProtobuf(soapHeader.value);
            GenericRequest pbReserveCommitRequest = GenericRequest.newBuilder().setHeader(pbHeader)
                    .setConnectionId(connectionId).build();

            LOG.finer("Built protobuf message `GenericRequest`:\n" + pbReserveCommitRequest);
            GenericAcknowledgment pbReserveCommitResponse = connectionProviderStub
                    .reserveCommit(pbReserveCommitRequest);
            // check the protobuf ReserveCommitResponse and either return a SOAP ServiceException or the generic Ack
            if (pbReserveCommitResponse.hasServiceException()) {
                addHeaders(soapHeader.value);
                throw new ServiceException(
                        pbReserveCommitResponse.getServiceException().getText(),
                        toSoap(pbReserveCommitResponse.getServiceException())
                );
            }
        } catch (ConverterException | StatusRuntimeException ex) {
            addHeaders(soapHeader.value);
            throw new ServiceException(
                    ex.toString(),
                    genericInternalServiceException(soapHeader.value.getProviderNSA(), connectionId, ex.toString())
            );
        }
    }

    @Generated(value = "org.apache.cxf.tools.wsdlto.WSDLToJava", date = "2020-04-27T16:21:07.875+02:00")
    public void queryNotification(String connectionId, Long startNotificationId, Long endNotificationId,
                                  jakarta.xml.ws.Holder<CommonHeaderType> soapHeader) throws ServiceException {
        LOG.info("SOAP->gRPC queryNotification from %s".formatted(soapHeader.value.getRequesterNSA()));
        LOG.fine("connection ID %s".formatted(connectionId));
        if (startNotificationId != null)
            LOG.fine("start notification ID %d".formatted(startNotificationId));
        if (endNotificationId != null)
            LOG.fine("end notification ID %d".formatted(endNotificationId));
        try {
            Header pbHeader = toProtobuf(soapHeader.value);
            QueryNotificationRequest.Builder pbQueryNotificationReguestBuilder = QueryNotificationRequest.newBuilder();
            pbQueryNotificationReguestBuilder.setHeader(pbHeader);
            pbQueryNotificationReguestBuilder.setConnectionId(connectionId);
            if (startNotificationId != null)
                pbQueryNotificationReguestBuilder.setStartNotificationId(startNotificationId);
            if (endNotificationId != null)
                pbQueryNotificationReguestBuilder.setEndNotificationId(endNotificationId);
            LOG.finer("Built protobuf message `QueryNotificationRequest`:\n" + pbQueryNotificationReguestBuilder.build());
            GenericAcknowledgment pbQueryNotificationResponse = connectionProviderStub
                    .queryNotification(pbQueryNotificationReguestBuilder.build());
            // check the protobuf QueryNotificationResponse and either return a SOAP ServiceException or the generic Ack
            if (pbQueryNotificationResponse.hasServiceException()) {
                addHeaders(soapHeader.value);
                throw new ServiceException(
                        pbQueryNotificationResponse.getServiceException().getText(),
                        toSoap(pbQueryNotificationResponse.getServiceException())
                );
            }
        } catch (ConverterException | StatusRuntimeException ex) {
            addHeaders(soapHeader.value);
            throw new ServiceException(
                    ex.toString(),
                    genericInternalServiceException(soapHeader.value.getProviderNSA(), null, ex.toString())
            );
        }
    }

    @Generated(value = "org.apache.cxf.tools.wsdlto.WSDLToJava", date = "2020-04-27T16:21:07.875+02:00")
    public void terminate(String connectionId, jakarta.xml.ws.Holder<CommonHeaderType> soapHeader) throws ServiceException {
        LOG.info("SOAP->gRPC terminate from %s".formatted(soapHeader.value.getRequesterNSA()));
        LOG.fine("connection ID %s".formatted(connectionId));
        try {
            Header pbHeader = toProtobuf(soapHeader.value);
            GenericRequest pbTerminateRequest = GenericRequest.newBuilder().setHeader(pbHeader)
                    .setConnectionId(connectionId).build();

            LOG.finer("Built protobuf message `GenericRequest`:\n" + pbTerminateRequest);
            GenericAcknowledgment pbTerminateResponse = connectionProviderStub
                    .terminate(pbTerminateRequest);
            // check the protobuf TerminateResponse and either return a SOAP ServiceException or the generic Ack
            if (pbTerminateResponse.hasServiceException()) {
                addHeaders(soapHeader.value);
                throw new ServiceException(
                        pbTerminateResponse.getServiceException().getText(),
                        toSoap(pbTerminateResponse.getServiceException())
                );
            }
        } catch (ConverterException | StatusRuntimeException ex) {
            addHeaders(soapHeader.value);
            throw new ServiceException(
                    ex.toString(),
                    genericInternalServiceException(soapHeader.value.getProviderNSA(), connectionId, ex.toString())
            );
        }
    }

    public void reserve(jakarta.xml.ws.Holder<String> connectionId, String globalReservationId,
                        String description, ReservationRequestCriteriaType soapCriteria,
                        jakarta.xml.ws.Holder<CommonHeaderType> soapHeader) throws ServiceException {
        LOG.info("SOAP->gRPC reserve from %s".formatted(soapHeader.value.getRequesterNSA()));
        if(connectionId.value != null)
            LOG.fine("connection ID %s".formatted(connectionId.value));
        LOG.fine("global reservation ID %s".formatted(globalReservationId));
        LOG.fine("description %s".formatted(description));
        LOG.fine("service type %s".formatted(soapCriteria.getServiceType()));
        if (soapCriteria.getVersion() != null)
            LOG.fine("version %d".formatted(soapCriteria.getVersion()));

        try {
            Header pbHeader = toProtobuf(soapHeader.value);
            ReserveRequest.Builder pbReserveRequestBuilder = ReserveRequest.newBuilder().setHeader(pbHeader);
            if (connectionId.value != null) {
                pbReserveRequestBuilder.setConnectionId(connectionId.value);
            }
            if (globalReservationId != null) {
                pbReserveRequestBuilder.setGlobalReservationId(globalReservationId);
            }
            if (description != null) {
                pbReserveRequestBuilder.setDescription(description);
            }

            // ReservationRequestCriteria
            ReservationRequestCriteria.Builder pbReservationRequestCriteriaBuilder = ReservationRequestCriteria
                    .newBuilder();
            if (soapCriteria.getVersion() != null)
                pbReservationRequestCriteriaBuilder.setVersion(soapCriteria.getVersion());

            // Schedule
            if (soapCriteria.getSchedule() != null) {
                Schedule.Builder pbScheduleBuilder = Schedule.newBuilder();
                if (soapCriteria.getSchedule().getStartTime() != null) {
                    LOG.fine("start time %s".formatted(soapCriteria.getSchedule().getStartTime()
                            .format(DateTimeFormatter.ISO_OFFSET_DATE_TIME)));
                    pbScheduleBuilder.setStartTime(Timestamps.parse(soapCriteria.getSchedule().getStartTime()
                            .format(DateTimeFormatter.ISO_OFFSET_DATE_TIME)));
                }
                if (soapCriteria.getSchedule().getEndTime() != null) {
                    LOG.fine("end time %s".formatted(soapCriteria.getSchedule().getEndTime()
                            .format(DateTimeFormatter.ISO_OFFSET_DATE_TIME)));
                    pbScheduleBuilder.setEndTime(Timestamps.parse(soapCriteria.getSchedule().getEndTime()
                            .format(DateTimeFormatter.ISO_OFFSET_DATE_TIME)));
                }
                pbReservationRequestCriteriaBuilder.setSchedule(pbScheduleBuilder);
            }
            if (soapCriteria.getServiceType() != null) {
                pbReservationRequestCriteriaBuilder.setServiceType(soapCriteria.getServiceType());
            }

            // Point2PointService
            for (Object elem : soapCriteria.getAny()) {
                /*
                    Contrary to the processing of the `pathTrace` element in the header, that was not referenced in
                    any of the WSDLs, and had to be mapped separately using JAXB, the P2PService _is_ referenced
                    from the WSDLs. This means that a Java class instance will be automatically created for us by the
                     `wsdl2java` generated code, but we still need to extract is from a wrapper `JAXBElement` instance.
                     In other words we don't have to explicitly unmarshall it as we had to with `pathTrace`.
                 */
                if (elem instanceof JAXBElement<?> bodyElem) {
                    if (bodyElem.getValue() instanceof P2PServiceBaseType) {
                        P2PServiceBaseType soapP2PService = (P2PServiceBaseType) bodyElem.getValue();

                        // Now we build the protobuf version of it.
                        PointToPointService.Builder pbP2PServiceBuilder = PointToPointService.newBuilder()
                                .setCapacity(soapP2PService.getCapacity());
                        if (soapP2PService.getDirectionality() != null) {
                            Directionality directionality = null;
                            switch (soapP2PService.getDirectionality()) {
                                case BIDIRECTIONAL:
                                    directionality = Directionality.BI_DIRECTIONAL;
                                    break;
                                case UNIDIRECTIONAL:
                                    directionality = Directionality.UNI_DIRECTIONAL;
                                    break;
                            }
                            pbP2PServiceBuilder.setDirectionality(directionality);
                        }

                        /*  Need to test each of the following SOAP elements for null. As some might not be set
                            in case of an Reserve message update. An update generally only specifies a subset. Eg
                            the initial Reservation included the wrong bandwidth. The update Reserve message will then
                            only specifies the bandwidth (with the correct value).
                         */
                        LOG.fine("source STP %s".formatted(soapP2PService.getSourceSTP()));
                        LOG.fine("destination STP %s".formatted(soapP2PService.getDestSTP()));
                        if (soapP2PService.isSymmetricPath() != null)
                            pbP2PServiceBuilder.setSymmetricPath(soapP2PService.isSymmetricPath());
                        if (soapP2PService.getSourceSTP() != null)
                            pbP2PServiceBuilder.setSourceStp(soapP2PService.getSourceSTP());
                        if (soapP2PService.getDestSTP() != null)
                            pbP2PServiceBuilder.setDestStp(soapP2PService.getDestSTP());

                        if (soapP2PService.getEro() != null) {
                            List<OrderedStpType> soapOrderedSTP = soapP2PService.getEro().getOrderedSTP();
                            soapOrderedSTP.sort(Comparator.comparing(OrderedStpType::getOrder));
                            pbP2PServiceBuilder.addAllEros(soapOrderedSTP.stream().map(OrderedStpType::getStp)
                                    .collect(Collectors.toList()));
                        }
                        if (soapP2PService.getParameter() != null) {
                            pbP2PServiceBuilder.putAllParameters(soapP2PService.getParameter().stream()
                                    .collect(Collectors.toMap(TypeValueType::getType, TypeValueType::getValue)));
                            pbReservationRequestCriteriaBuilder.setPtps(pbP2PServiceBuilder);
                        }
                    }
                }
            }
            pbReserveRequestBuilder.setCriteria(pbReservationRequestCriteriaBuilder);
            LOG.finer("Built protobuf message `ReserveRequest`:\n" + pbReserveRequestBuilder);
            ReserveResponse pbReserveResponse = connectionProviderStub.reserve(pbReserveRequestBuilder.build());
            // check the protobuf ReserveResponse and either return a SOAP ServiceException or the connection ID
            if (pbReserveResponse.hasServiceException()) {
                addHeaders(soapHeader.value);
                throw new ServiceException(
                        pbReserveResponse.getServiceException().getText(),
                        toSoap(pbReserveResponse.getServiceException())
                );
            }
            connectionId.value = pbReserveResponse.getConnectionId();
        } catch (ConverterException | ParseException | StatusRuntimeException ex)  {
            addHeaders(soapHeader.value);
            throw new ServiceException(
                    ex.toString(),
                    genericInternalServiceException(soapHeader.value.getProviderNSA(), connectionId.value, ex.toString())
            );
        }
    }

    @Generated(value = "org.apache.cxf.tools.wsdlto.WSDLToJava", date = "2020-04-27T16:21:07.875+02:00")
    public java.util.List<QueryResultResponseType> queryResultSync(String connectionId, Long startResultId, Long endResultId,
                                                                   jakarta.xml.ws.Holder<CommonHeaderType> soapHeader) throws Error {
        LOG.info("SOAP->gRPC queryResultSync from %s".formatted(soapHeader.value.getRequesterNSA()));
        LOG.fine("connection ID %s".formatted(connectionId));
        if (startResultId != null)
            LOG.fine("start result ID %d".formatted(startResultId));
        if (endResultId != null)
            LOG.fine("end result ID %d".formatted(endResultId));
        try {
            Header pbHeader = toProtobuf(soapHeader.value);
            QueryResultRequest.Builder pbQueryResultReguestBuilder = QueryResultRequest.newBuilder();
            pbQueryResultReguestBuilder.setHeader(pbHeader);
            pbQueryResultReguestBuilder.setConnectionId(connectionId);
            if (startResultId != null)
                pbQueryResultReguestBuilder.setStartResultId(startResultId);
            if (endResultId != null)
                pbQueryResultReguestBuilder.setEndResultId(endResultId);
            LOG.finer("Built protobuf message `QueryResultRequest`:\n" + pbQueryResultReguestBuilder.build());
            // queryResultSync returns a QueryResultConfirmedRequest bypassing the generic Response messages
            QueryResultConfirmedRequest pbQueryResultConfirmedRequest = connectionProviderStub
                    .queryResultSync(pbQueryResultReguestBuilder.build());
            // the pbQueryResultConfirmedRequest does not have a service exception field,
            // it is assumed that the query operations does not cause exceptions in SuPA
            return toSoap(pbQueryResultConfirmedRequest);
        } catch (ConverterException | StatusRuntimeException ex) {
            addHeaders(soapHeader.value);
            throw new Error(
                    ex.toString(),
                    genericInternalError(soapHeader.value.getProviderNSA(), null, ex.toString())
            );
        }
    }

    @Generated(value = "org.apache.cxf.tools.wsdlto.WSDLToJava", date = "2020-04-27T16:21:07.875+02:00")
    public void release(String connectionId, jakarta.xml.ws.Holder<CommonHeaderType> soapHeader) throws ServiceException {
        LOG.info("SOAP->gRPC release from %s".formatted(soapHeader.value.getRequesterNSA()));
        LOG.fine("connection ID %s".formatted(connectionId));
        try {
            Header pbHeader = toProtobuf(soapHeader.value);
            GenericRequest pbReleaseRequest = GenericRequest.newBuilder().setHeader(pbHeader)
                    .setConnectionId(connectionId).build();

            LOG.finer("Built protobuf message `GenericRequest`:\n" + pbReleaseRequest);
            GenericAcknowledgment pbReleaseResponse = connectionProviderStub
                    .release(pbReleaseRequest);
            // check the protobuf ReleaseResponse and either return a SOAP ServiceException or the generic Ack
            if (pbReleaseResponse.hasServiceException()) {
                addHeaders(soapHeader.value);
                throw new ServiceException(
                        pbReleaseResponse.getServiceException().getText(),
                        toSoap(pbReleaseResponse.getServiceException())
                );
            }
        } catch (ConverterException | StatusRuntimeException ex) {
            addHeaders(soapHeader.value);
            throw new ServiceException(
                    ex.toString(),
                    genericInternalServiceException(soapHeader.value.getProviderNSA(), connectionId, ex.toString())
            );
        }
    }

    public void reserveAbort(String connectionId, jakarta.xml.ws.Holder<CommonHeaderType> soapHeader) throws ServiceException {
        LOG.info("SOAP->gRPC reserveAbort from %s".formatted(soapHeader.value.getRequesterNSA()));
        LOG.fine("connection ID %s".formatted(connectionId));
        try {
            Header pbHeader = toProtobuf(soapHeader.value);
            GenericRequest pbReserveAbortRequest = GenericRequest.newBuilder().setHeader(pbHeader)
                    .setConnectionId(connectionId).build();

            LOG.finer("Built protobuf message `GenericRequest`:\n" + pbReserveAbortRequest);
            GenericAcknowledgment pbReserveAbortResponse = connectionProviderStub
                    .reserveAbort(pbReserveAbortRequest);
            // check the protobuf ReserveAbortResponse and either return a SOAP ServiceException or the generic Ack
            if (pbReserveAbortResponse.hasServiceException()) {
                addHeaders(soapHeader.value);
                throw new ServiceException(
                        pbReserveAbortResponse.getServiceException().getText(),
                        toSoap(pbReserveAbortResponse.getServiceException())
                );
            }
        } catch (ConverterException | StatusRuntimeException ex) {
            addHeaders(soapHeader.value);
            throw new ServiceException(
                    ex.toString(),
                    genericInternalServiceException(soapHeader.value.getProviderNSA(), connectionId, ex.toString())
            );
        }
    }

    @Generated(value = "org.apache.cxf.tools.wsdlto.WSDLToJava", date = "2020-04-27T16:21:07.875+02:00")
    public GenericAcknowledgmentType querySummary(QueryType querySummary, jakarta.xml.ws.Holder<CommonHeaderType> soapHeader) throws ServiceException {
        LOG.info("SOAP->gRPC querySummary from %s".formatted(soapHeader.value.getRequesterNSA()));
        for (String connectionId : querySummary.getConnectionId())
            LOG.fine("connection ID %s".formatted(connectionId));
        for (String globalReservationId : querySummary.getGlobalReservationId())
            LOG.fine("global reservation ID %s".formatted(globalReservationId));
        if (querySummary.getIfModifiedSince() != null)
            LOG.fine("if modified since %s".formatted(querySummary.getIfModifiedSince().format(DateTimeFormatter.ISO_OFFSET_DATE_TIME)));
        try {
            Header pbHeader = toProtobuf(soapHeader.value);
            QueryRequest.Builder pbQueryReguestBuilder = QueryRequest.newBuilder();
            pbQueryReguestBuilder.setHeader(pbHeader);
            if (querySummary.getIfModifiedSince() != null) {
                pbQueryReguestBuilder.setIfModifiedSince(Timestamps.parse(querySummary.getIfModifiedSince().format(DateTimeFormatter.ISO_OFFSET_DATE_TIME)));
            }
            pbQueryReguestBuilder.addAllConnectionId(querySummary.getConnectionId());
            pbQueryReguestBuilder.addAllGlobalReservationId(querySummary.getGlobalReservationId());
            LOG.finer("Built protobuf message `QueryRequest`:\n" + pbQueryReguestBuilder.build());
            GenericAcknowledgment pbQueryResponse = connectionProviderStub
                    .querySummary(pbQueryReguestBuilder.build());
            // check the protobuf QueryResponse and either return a SOAP ServiceException or the generic Ack
            if (pbQueryResponse.hasServiceException()) {
                addHeaders(soapHeader.value);
                throw new ServiceException(
                        pbQueryResponse.getServiceException().getText(),
                        toSoap(pbQueryResponse.getServiceException())
                );
            }
            var objectFactory = new nl.surf.polynsi.soap.connection.types.ObjectFactory();
            return objectFactory.createGenericAcknowledgmentType();
        } catch (ConverterException | ParseException | StatusRuntimeException ex) {
            addHeaders(soapHeader.value);
            throw new ServiceException(
                    ex.toString(),
                    genericInternalServiceException(soapHeader.value.getProviderNSA(), null, ex.toString())
            );
        }
    }
    
    @Generated(value = "org.apache.cxf.tools.wsdlto.WSDLToJava", date = "2020-04-27T16:21:07.875+02:00")
    public void queryResult(String connectionId, Long startResultId, Long endResultId,
                            jakarta.xml.ws.Holder<CommonHeaderType> soapHeader) throws ServiceException {
        LOG.info("SOAP->gRPC queryResult from %s".formatted(soapHeader.value.getRequesterNSA()));
        LOG.fine("connection ID %s".formatted(connectionId));
        if (startResultId != null)
            LOG.fine("start result ID %d".formatted(startResultId));
        if (endResultId != null)
            LOG.fine("end restult ID %d".formatted(endResultId));
        try {
            Header pbHeader = toProtobuf(soapHeader.value);
            QueryResultRequest.Builder pbQueryResultReguestBuilder = QueryResultRequest.newBuilder();
            pbQueryResultReguestBuilder.setHeader(pbHeader);
            pbQueryResultReguestBuilder.setConnectionId(connectionId);
            if (startResultId != null)
                pbQueryResultReguestBuilder.setStartResultId(startResultId);
            if (endResultId != null)
                pbQueryResultReguestBuilder.setEndResultId(endResultId);
            LOG.finer("Built protobuf message `QueryResultRequest`:\n" + pbQueryResultReguestBuilder.build());
            GenericAcknowledgment pbQueryResultResponse = connectionProviderStub
                    .queryResult(pbQueryResultReguestBuilder.build());
            // check the protobuf QueryResultResponse and either return a SOAP ServiceException or the generic Ack
            if (pbQueryResultResponse.hasServiceException()) {
                addHeaders(soapHeader.value);
                throw new ServiceException(
                        pbQueryResultResponse.getServiceException().getText(),
                        toSoap(pbQueryResultResponse.getServiceException())
                );
            }
        } catch (ConverterException | StatusRuntimeException ex) {
            addHeaders(soapHeader.value);
            throw new ServiceException(
                    ex.toString(),
                    genericInternalServiceException(soapHeader.value.getProviderNSA(), null, ex.toString())
            );
        }
    }

    @Generated(value = "org.apache.cxf.tools.wsdlto.WSDLToJava", date = "2020-04-27T16:21:07.875+02:00")
    public QueryNotificationConfirmedType queryNotificationSync(QueryNotificationType queryNotificationSync,
                                                                jakarta.xml.ws.Holder<CommonHeaderType> soapHeader) throws Error {
        LOG.info("SOAP->gRPC queryNotificationSync from %s".formatted(soapHeader.value.getRequesterNSA()));
        LOG.fine("connection ID %s".formatted(queryNotificationSync.getConnectionId()));
        if (queryNotificationSync.getStartNotificationId() != null)
            LOG.fine("start notification ID %d".formatted(queryNotificationSync.getStartNotificationId()));
        if (queryNotificationSync.getEndNotificationId() != null)
            LOG.fine("end notification ID %d".formatted(queryNotificationSync.getEndNotificationId()));
        try {
            Header pbHeader = toProtobuf(soapHeader.value);
            QueryNotificationRequest.Builder pbQueryNotificationReguestBuilder = QueryNotificationRequest.newBuilder();
            pbQueryNotificationReguestBuilder.setHeader(pbHeader);
            pbQueryNotificationReguestBuilder.setConnectionId(queryNotificationSync.getConnectionId());
            if (queryNotificationSync.getStartNotificationId() != null)
                pbQueryNotificationReguestBuilder.setStartNotificationId(queryNotificationSync.getStartNotificationId());
            if (queryNotificationSync.getEndNotificationId() != null)
                pbQueryNotificationReguestBuilder.setEndNotificationId(queryNotificationSync.getEndNotificationId());
            LOG.finer("Built protobuf message `QueryNotificationReguest`:\n" + pbQueryNotificationReguestBuilder.build());
            // queryNotificationSync returns a QueryNotificationConfirmedRequest bypassing the generic Response messages
            QueryNotificationConfirmedRequest pbQueryConfirmedRequest = connectionProviderStub
                    .queryNotificationSync(pbQueryNotificationReguestBuilder.build());
            // the pbQueryConfirmedRequest does not have a service exception field,
            // it is assumed that the query operations does not cause exceptions in SuPA
            return toSoap(pbQueryConfirmedRequest);
        } catch (ConverterException | StatusRuntimeException ex) {
            addHeaders(soapHeader.value);
            throw new Error(
                    ex.toString(),
                    genericInternalError(soapHeader.value.getProviderNSA(), null, ex.toString())
            );
        }
    }

}
