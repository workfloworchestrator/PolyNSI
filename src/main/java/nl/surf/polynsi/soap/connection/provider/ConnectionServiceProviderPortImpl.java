/**
 * Please modify this class to meet your needs
 * This class is not complete
 */

package nl.surf.polynsi.soap.connection.provider;

import com.google.protobuf.util.Timestamps;
import io.grpc.StatusRuntimeException;
import net.devh.boot.grpc.client.inject.GrpcClient;
import nl.surf.polynsi.ConverterException;
import nl.surf.polynsi.soap.connection.types.*;
import nl.surf.polynsi.soap.framework.headers.CommonHeaderType;
import nl.surf.polynsi.soap.framework.types.ServiceExceptionType;
import nl.surf.polynsi.soap.services.p2p.P2PServiceBaseType;
import nl.surf.polynsi.soap.services.types.OrderedStpType;
import nl.surf.polynsi.soap.services.types.TypeValueType;
import org.apache.cxf.jaxb.JAXBDataBinding;
import org.ogf.nsi.grpc.connection.common.Header;
import org.ogf.nsi.grpc.connection.common.Schedule;
import org.ogf.nsi.grpc.connection.provider.*;
import org.ogf.nsi.grpc.connection.requester.QuerySummaryConfirmedRequest;
import org.ogf.nsi.grpc.services.Directionality;
import org.ogf.nsi.grpc.services.PointToPointService;

import javax.annotation.Generated;
import javax.annotation.Resource;
import javax.xml.bind.JAXBElement;
import javax.xml.bind.JAXBException;
import javax.xml.namespace.QName;
import javax.xml.ws.WebServiceContext;
import java.text.ParseException;
import java.time.OffsetDateTime;
import java.time.format.DateTimeFormatter;
import java.util.ArrayList;
import java.util.Comparator;
import java.util.List;
import java.util.logging.Logger;
import java.util.stream.Collectors;

import static com.google.protobuf.util.Timestamps.EPOCH;
import static nl.surf.polynsi.Converter.toProtobuf;
import static nl.surf.polynsi.Converter.toSoap;

/**
 * This class was generated by Apache CXF 3.3.5
 * 2020-04-27T16:21:07.875+02:00
 * Generated source version: 3.3.5
 */


@org.apache.cxf.feature.Features (features = {"nl.surf.polynsi.soap.connection.provider.PrettyLoggingFeature"})
@javax.jws.WebService(serviceName = "ConnectionServiceProvider",
        portName = "ConnectionServiceProviderPort",
        targetNamespace = "http://schemas.ogf.org/nsi/2013/12/connection/provider",
        wsdlLocation = "wsdl/connection/ogf_nsi_connection_provider_v2_0.wsdl",
        endpointInterface = "nl.surf.polynsi.soap.connection.provider.ConnectionProviderPort")
public class ConnectionServiceProviderPortImpl implements ConnectionProviderPort {

    @Generated(value = "org.apache.cxf.tools.wsdlto.WSDLToJava", date = "2020-04-27T16:21:07.875+02:00")
    private static final Logger LOG = Logger.getLogger(ConnectionServiceProviderPortImpl.class.getName());

    @GrpcClient("connection_provider")
    private ConnectionProviderGrpc.ConnectionProviderBlockingStub connectionProviderStub;

    @Resource
    private  WebServiceContext webServiceContext;

    private void addHeaders(CommonHeaderType soapHeader) {
            // clear any extension from header, fix for 'PathTraceType is not known to this context' error
        soapHeader.getAny().clear();
        /*
            Add nsiHeader to automatically generate ServiceException and Error messages
            using a generic way of adding SOAP headers to a message. This probably can also be implemented
            with a CXF SoapHeaderInterceptor that extends AbstractSoapInterceptor.
         */
        try {
            List<org.apache.cxf.headers.Header> headers = new ArrayList<>();
            soapHeader.setReplyTo(null);
            org.apache.cxf.headers.Header nsiHeader = new org.apache.cxf.headers.Header(
                    new QName("http://schemas.ogf.org/nsi/2013/12/framework/headers", "nsiHeader"),
                    soapHeader,
                    new JAXBDataBinding(CommonHeaderType.class)
            );
            headers.add(nsiHeader);
            webServiceContext.getMessageContext().put(org.apache.cxf.headers.Header.HEADER_LIST, headers);
        }  catch (JAXBException ex) {
            LOG.warning(ex.toString());
        }
    }

    private ServiceExceptionType newServiceException(String providerNSA, String connectionId) {
        var objectFactory = new nl.surf.polynsi.soap.framework.types.ObjectFactory();
        ServiceExceptionType serviceException = objectFactory.createServiceExceptionType();
        serviceException.setNsaId(providerNSA);
        serviceException.setConnectionId(connectionId);
        return serviceException;
    }

    private ServiceExceptionType notImplementedServiceException(String providerNSA, String feature) {
        var serviceException = newServiceException(providerNSA, null);
        serviceException.setErrorId("00103");
        serviceException.setText(
                String.format("NOT_IMPLEMENTED: Requested feature has not been implemented (%s)", feature)
        );
        return serviceException;
    }

    private GenericErrorType notImplementedError (String providerNSA, String feature) {
        var objectFactory = new nl.surf.polynsi.soap.connection.types.ObjectFactory();
        GenericErrorType error = objectFactory.createGenericErrorType();
        error.setServiceException(notImplementedServiceException(providerNSA, feature));
        return error;
    }

    private ServiceExceptionType genericInternalServiceException(String providerNSA, String connectionId, String text) {
        var serviceException = newServiceException(providerNSA, connectionId);
        serviceException.setErrorId("00500");
        serviceException.setText(
                String.format("GENERIC_INTERNAL_ERROR: An internal error has caused a message processing failure (%s)", text)
        );
        return serviceException;
    }

    private GenericErrorType genericInternalError (String providerNSA, String connectionId, String text) {
        var objectFactory = new nl.surf.polynsi.soap.connection.types.ObjectFactory();
        GenericErrorType error = objectFactory.createGenericErrorType();
        error.setServiceException(genericInternalServiceException(providerNSA, connectionId, text));
        return error;
    }
    
    @Generated(value = "org.apache.cxf.tools.wsdlto.WSDLToJava", date = "2020-04-27T16:21:07.875+02:00")
    public void provision(String connectionId, javax.xml.ws.Holder<CommonHeaderType> soapHeader) throws ServiceException {
        LOG.info(String.format("SOAP->gRPC provision from %s", soapHeader.value.getRequesterNSA()));
        LOG.fine(String.format("connection ID %s", connectionId));
        try {
            Header pbHeader = toProtobuf(soapHeader.value);
            ProvisionRequest pbProvisionRequest = ProvisionRequest.newBuilder().setHeader(pbHeader)
                    .setConnectionId(connectionId).build();

            LOG.finer("Built protobuf message `ProvisionRequest`:\n" + pbProvisionRequest);
            ProvisionResponse pbProvisionResponse = connectionProviderStub
                    .provision(pbProvisionRequest);
            // check the protobuf ProvisionResponse and either return a SOAP ServiceException or the generic Ack
            if (pbProvisionResponse.hasServiceException()) {
                addHeaders(soapHeader.value);
                throw new ServiceException(
                        pbProvisionResponse.getServiceException().getText(),
                        toSoap(pbProvisionResponse.getServiceException())
                );
            }
        } catch (ConverterException | StatusRuntimeException ex) {
            addHeaders(soapHeader.value);
            throw new ServiceException(
                    ex.toString(),
                    genericInternalServiceException(soapHeader.value.getProviderNSA(), connectionId, ex.toString())
            );
        }
    }

    @Generated(value = "org.apache.cxf.tools.wsdlto.WSDLToJava", date = "2020-04-27T16:21:07.875+02:00")
    public QuerySummaryConfirmedType querySummarySync(QueryType querySummarySync,
                                                      javax.xml.ws.Holder<CommonHeaderType> soapHeader) throws Error {
        LOG.info(String.format("SOAP->gRPC querySummarySync from %s", soapHeader.value.getRequesterNSA()));
        for (String connectionId : querySummarySync.getConnectionId())
            LOG.fine(String.format("connection ID %s", connectionId));
        for (String globalReservationId : querySummarySync.getGlobalReservationId())
            LOG.fine(String.format("global reservation ID %s", globalReservationId));
        if (querySummarySync.getIfModifiedSince() != null)
            LOG.fine(String.format("if modified since %s", querySummarySync.getIfModifiedSince().format(DateTimeFormatter.ISO_OFFSET_DATE_TIME)));
        try {
            Header pbHeader = toProtobuf(soapHeader.value);
            QuerySummaryRequest.Builder pbQuerySummaryReguestBuilder = QuerySummaryRequest.newBuilder();
            pbQuerySummaryReguestBuilder.setHeader(pbHeader);
            if (querySummarySync.getIfModifiedSince() != null) {
                pbQuerySummaryReguestBuilder.setIfModifiedSince(Timestamps.parse(
                        querySummarySync.getIfModifiedSince().format(DateTimeFormatter.ISO_OFFSET_DATE_TIME)
                ));
            }
            pbQuerySummaryReguestBuilder.addAllConnectionId(querySummarySync.getConnectionId());
            pbQuerySummaryReguestBuilder.addAllGlobalReservationId(querySummarySync.getGlobalReservationId());
            LOG.finer("Built protobuf message `QuerySummaryRequest`:\n" + pbQuerySummaryReguestBuilder.build());
            // QuerySummarySync returns a QuerySummaryConfirmedRequest bypassing the associated Response messages
            QuerySummaryConfirmedRequest pbQuerySummaryConfirmedRequest = connectionProviderStub
                    .querySummarySync(pbQuerySummaryReguestBuilder.build());
            // the pbQuerySummaryConfirmedRequest does not have a service exception field,
            // it is assumed that the query summary operations does not cause exceptions in SuPA

            var objectFactory = new nl.surf.polynsi.soap.connection.types.ObjectFactory();
            QuerySummaryConfirmedType soapQuerySummaryConfirmed = objectFactory.createQuerySummaryConfirmedType();
            for (QuerySummaryResultType soapQuerySummaryResult : toSoap(pbQuerySummaryConfirmedRequest))
                soapQuerySummaryConfirmed.getReservation().add(soapQuerySummaryResult);
            OffsetDateTime lastModified = null;
            if (!pbQuerySummaryConfirmedRequest.getLastModified().equals(EPOCH)) {
                lastModified = toSoap(pbQuerySummaryConfirmedRequest.getLastModified());
            }
            soapQuerySummaryConfirmed.setLastModified(lastModified);
            return soapQuerySummaryConfirmed;
        } catch (ConverterException | ParseException | StatusRuntimeException ex) {
            addHeaders(soapHeader.value);
            throw new Error(
                    ex.toString(),
                    genericInternalError(soapHeader.value.getProviderNSA(), null, ex.toString())
            );
        }
    }

    @Generated(value = "org.apache.cxf.tools.wsdlto.WSDLToJava", date = "2020-04-27T16:21:07.875+02:00")
    public GenericAcknowledgmentType queryRecursive(QueryType queryRecursive, javax.xml.ws.Holder<CommonHeaderType> soapHeader) throws ServiceException {
        LOG.info(String.format("SOAP->gRPC queryRecursive from %s", soapHeader.value.getRequesterNSA()));
        // TODO: replace notImplementedServiceException with queryRecursive implementation
        var serviceException = notImplementedServiceException(soapHeader.value.getProviderNSA(), "queryRecursive");
        throw new ServiceException(serviceException.getText(), serviceException);
        // try {
        //     GenericAcknowledgmentType _return = null;
        //     return _return;
        // } catch (java.lang.Exception ex) {
        //     addHeaders(soapHeader.value);
        //     throw new ServiceException(
        //             ex.toString(),
        //             genericInternalServiceException(soapHeader.value.getProviderNSA(), null, ex.toString())
        //     );
        // }
    }

    public void reserveCommit(String connectionId, javax.xml.ws.Holder<CommonHeaderType> soapHeader) throws ServiceException {
        LOG.info(String.format("SOAP->gRPC reserveCommit from %s", soapHeader.value.getRequesterNSA()));
        LOG.fine(String.format("connection ID %s", connectionId));
        try {
            Header pbHeader = toProtobuf(soapHeader.value);
            ReserveCommitRequest pbReserveCommitRequest = ReserveCommitRequest.newBuilder().setHeader(pbHeader)
                    .setConnectionId(connectionId).build();

            LOG.finer("Built protobuf message `ReserveCommitRequest`:\n" + pbReserveCommitRequest);
            ReserveCommitResponse pbReserveCommitResponse = connectionProviderStub
                    .reserveCommit(pbReserveCommitRequest);
            // check the protobuf ReserveCommitResponse and either return a SOAP ServiceException or the generic Ack
            if (pbReserveCommitResponse.hasServiceException()) {
                addHeaders(soapHeader.value);
                throw new ServiceException(
                        pbReserveCommitResponse.getServiceException().getText(),
                        toSoap(pbReserveCommitResponse.getServiceException())
                );
            }
        } catch (ConverterException | StatusRuntimeException ex) {
            addHeaders(soapHeader.value);
            throw new ServiceException(
                    ex.toString(),
                    genericInternalServiceException(soapHeader.value.getProviderNSA(), connectionId, ex.toString())
            );
        }
    }

    @Generated(value = "org.apache.cxf.tools.wsdlto.WSDLToJava", date = "2020-04-27T16:21:07.875+02:00")
    public void queryNotification(String connectionId, Long startNotificationId, Long endNotificationId,
                                  javax.xml.ws.Holder<CommonHeaderType> soapHeader) throws ServiceException {
        LOG.info(String.format("SOAP->gRPC queryNotification from %s", soapHeader.value.getRequesterNSA()));
        LOG.fine(String.format("connection ID %s", connectionId));
        LOG.fine(String.format("start notification ID %d", startNotificationId));
        LOG.fine(String.format("end notification ID %d", endNotificationId));
        // TODO: replace notImplementedServiceException with queryNotification implementation
        var serviceException = notImplementedServiceException(soapHeader.value.getProviderNSA(), "queryNotification");
        throw new ServiceException(serviceException.getText(), serviceException);

        // try {
        // } catch (java.lang.Exception ex) {
        //     addHeaders(soapHeader.value);
        //     throw new ServiceException(
        //             ex.toString(),
        //             genericInternalServiceException(soapHeader.value.getProviderNSA(), connectionId, ex.toString())
        //     );
        // }
    }

    @Generated(value = "org.apache.cxf.tools.wsdlto.WSDLToJava", date = "2020-04-27T16:21:07.875+02:00")
    public void terminate(String connectionId, javax.xml.ws.Holder<CommonHeaderType> soapHeader) throws ServiceException {
        LOG.info(String.format("SOAP->gRPC terminate from %s", soapHeader.value.getRequesterNSA()));
        LOG.fine(String.format("connection ID %s", connectionId));
        try {
            Header pbHeader = toProtobuf(soapHeader.value);
            TerminateRequest pbTerminateRequest = TerminateRequest.newBuilder().setHeader(pbHeader)
                    .setConnectionId(connectionId).build();

            LOG.finer("Built protobuf message `TerminateRequest`:\n" + pbTerminateRequest);
            TerminateResponse pbTerminateResponse = connectionProviderStub
                    .terminate(pbTerminateRequest);
            // check the protobuf TerminateResponse and either return a SOAP ServiceException or the generic Ack
            if (pbTerminateResponse.hasServiceException()) {
                addHeaders(soapHeader.value);
                throw new ServiceException(
                        pbTerminateResponse.getServiceException().getText(),
                        toSoap(pbTerminateResponse.getServiceException())
                );
            }
        } catch (ConverterException | StatusRuntimeException ex) {
            addHeaders(soapHeader.value);
            throw new ServiceException(
                    ex.toString(),
                    genericInternalServiceException(soapHeader.value.getProviderNSA(), connectionId, ex.toString())
            );
        }
    }

    public void reserve(javax.xml.ws.Holder<String> connectionId, String globalReservationId,
                        String description, ReservationRequestCriteriaType soapCriteria,
                        javax.xml.ws.Holder<CommonHeaderType> soapHeader) throws ServiceException {
        LOG.info(String.format("SOAP->gRPC reserve from %s", soapHeader.value.getRequesterNSA()));
        if(connectionId.value != null)
            LOG.fine(String.format("connection ID %s", connectionId.value));
        LOG.fine(String.format("global reservation ID %s", globalReservationId));
        LOG.fine(String.format("description %s", description));
        LOG.fine(String.format("service type %s", soapCriteria.getServiceType()));
        LOG.fine(String.format("version %d", soapCriteria.getVersion()));

        try {
            Header pbHeader = toProtobuf(soapHeader.value);
            ReserveRequest.Builder pbReserveRequestBuilder = ReserveRequest.newBuilder().setHeader(pbHeader);
            if (connectionId.value != null) {
                pbReserveRequestBuilder.setConnectionId(connectionId.value);
            }
            if (globalReservationId != null) {
                pbReserveRequestBuilder.setGlobalReservationId(globalReservationId);
            }
            if (description != null) {
                pbReserveRequestBuilder.setDescription(description);
            }

            // ReservationRequestCriteria
            ReservationRequestCriteria.Builder pbReservationRequestCriteriaBuilder = ReservationRequestCriteria
                    .newBuilder().setVersion(soapCriteria.getVersion());

            // Schedule
            if (soapCriteria.getSchedule() != null) {
                Schedule.Builder pbScheduleBuilder = Schedule.newBuilder();
                if (soapCriteria.getSchedule().getStartTime() != null) {
                    LOG.fine(String.format("start time %s", soapCriteria.getSchedule().getStartTime()
                            .format(DateTimeFormatter.ISO_OFFSET_DATE_TIME)));
                    LOG.fine(String.format("end time %s", soapCriteria.getSchedule().getEndTime()
                            .format(DateTimeFormatter.ISO_OFFSET_DATE_TIME)));
                    pbScheduleBuilder.setStartTime(Timestamps.parse(soapCriteria.getSchedule().getStartTime()
                            .format(DateTimeFormatter.ISO_OFFSET_DATE_TIME)));
                }
                if (soapCriteria.getSchedule().getEndTime() != null) {
                    pbScheduleBuilder.setEndTime(Timestamps.parse(soapCriteria.getSchedule().getEndTime()
                            .format(DateTimeFormatter.ISO_OFFSET_DATE_TIME)));
                }
                pbReservationRequestCriteriaBuilder.setSchedule(pbScheduleBuilder);
            }
            if (soapCriteria.getServiceType() != null) {
                pbReservationRequestCriteriaBuilder.setServiceType(soapCriteria.getServiceType());
            }

            // Point2PointService
            for (Object elem : soapCriteria.getAny()) {
                /*
                    Contrary to the processing of the `pathTrace` element in the header, that was not referenced in
                    any of the WSDLs, and had to be mapped separately using JAXB, the P2PService _is_ referenced
                    from the WSDLs. This means that a Java class instance will be automatically created for us by the
                     `wsdl2java` generated code, but we still need to extract is from a wrapper `JAXBElement` instance.
                     In other words we don't have to explicitly unmarshall it as we had to with `pathTrace`.
                 */
                if (elem instanceof JAXBElement) {
                    JAXBElement<?> bodyElem = (JAXBElement<?>) elem;
                    if (bodyElem.getValue() instanceof P2PServiceBaseType) {
                        P2PServiceBaseType soapP2PService = (P2PServiceBaseType) bodyElem.getValue();

                        // Now we build the protobuf version of it.
                        PointToPointService.Builder pbP2PServiceBuilder = PointToPointService.newBuilder()
                                .setCapacity(soapP2PService.getCapacity());
                        if (soapP2PService.getDirectionality() != null) {
                            Directionality directionality = null;
                            switch (soapP2PService.getDirectionality()) {
                                case BIDIRECTIONAL:
                                    directionality = Directionality.BI_DIRECTIONAL;
                                    break;
                                case UNIDIRECTIONAL:
                                    directionality = Directionality.UNI_DIRECTIONAL;
                                    break;
                            }
                            pbP2PServiceBuilder.setDirectionality(directionality);
                        }

                        /*  TODO Need to test each of the following SOAP elements for null. As some might not be set
                            in case of an Reserve message update. An update generally only specifies a subset. Eg
                            the initial Reservation included the wrong bandwidth. The update Reserve message will then
                            only specifies the bandwidth (with the correct value).
                         */
                        LOG.fine(String.format("source STP %s", soapP2PService.getSourceSTP()));
                        LOG.fine(String.format("destination STP %s", soapP2PService.getDestSTP()));
                        pbP2PServiceBuilder.setSymmetricPath(soapP2PService.isSymmetricPath())
                                .setSourceStp(soapP2PService.getSourceSTP()).setDestStp(soapP2PService.getDestSTP());

                        if (soapP2PService.getEro() != null) {
                            List<OrderedStpType> soapOrderedSTP = soapP2PService.getEro().getOrderedSTP();
                            soapOrderedSTP.sort(Comparator.comparing(OrderedStpType::getOrder));
                            pbP2PServiceBuilder.addAllEros(soapOrderedSTP.stream().map(OrderedStpType::getStp)
                                    .collect(Collectors.toList()));
                        }
                        if (soapP2PService.getParameter() != null) {
                            pbP2PServiceBuilder.putAllParameters(soapP2PService.getParameter().stream()
                                    .collect(Collectors.toMap(TypeValueType::getType, TypeValueType::getValue)));
                            pbReservationRequestCriteriaBuilder.setPtps(pbP2PServiceBuilder);
                        }
                    }
                }
            }
            pbReserveRequestBuilder.setCriteria(pbReservationRequestCriteriaBuilder);
            LOG.finer("Built protobuf message `ReserveRequest`:\n" + pbReserveRequestBuilder);
            ReserveResponse pbReserveResponse = connectionProviderStub.reserve(pbReserveRequestBuilder.build());
            // check the protobuf ReserveResponse and either return a SOAP ServiceException or the connection ID
            if (pbReserveResponse.hasServiceException()) {
                addHeaders(soapHeader.value);
                throw new ServiceException(
                        pbReserveResponse.getServiceException().getText(),
                        toSoap(pbReserveResponse.getServiceException())
                );
            }
            connectionId.value = pbReserveResponse.getConnectionId();
        } catch (ConverterException | ParseException | StatusRuntimeException ex)  {
            addHeaders(soapHeader.value);
            throw new ServiceException(
                    ex.toString(),
                    genericInternalServiceException(soapHeader.value.getProviderNSA(), connectionId.value, ex.toString())
            );
        }
    }

    @Generated(value = "org.apache.cxf.tools.wsdlto.WSDLToJava", date = "2020-04-27T16:21:07.875+02:00")
    public java.util.List<QueryResultResponseType> queryResultSync(String connectionId, Long startResultId, Long endResultId,
                                                                   javax.xml.ws.Holder<CommonHeaderType> soapHeader) throws Error {
        LOG.info(String.format("SOAP->gRPC queryResultSync from %s", soapHeader.value.getRequesterNSA()));
        LOG.fine(String.format("connection ID %s", connectionId));
        LOG.fine(String.format("start result ID %d", startResultId));
        LOG.fine(String.format("end result ID %d", endResultId));
        // TODO: replace notImplementedError with queryResultSync implementation
        var error = notImplementedError(soapHeader.value.getProviderNSA(), "queryResultSync");
        throw new Error(error.getServiceException().getText(), error);
        // try {
        //     java.util.List<QueryResultResponseType> _return = null;
        //     return _return;
        // } catch (java.lang.Exception ex) {
        //     addHeaders(soapHeader.value);
        //     throw new Error(
        //             ex.toString(),
        //             genericInternalError(soapHeader.value.getProviderNSA(), connectionId, ex.toString())
        //     );
        // }
    }

    @Generated(value = "org.apache.cxf.tools.wsdlto.WSDLToJava", date = "2020-04-27T16:21:07.875+02:00")
    public void release(String connectionId, javax.xml.ws.Holder<CommonHeaderType> soapHeader) throws ServiceException {
        LOG.info(String.format("SOAP->gRPC release from %s", soapHeader.value.getRequesterNSA()));
        LOG.fine(String.format("connection ID %s", connectionId));
        try {
            Header pbHeader = toProtobuf(soapHeader.value);
            ReleaseRequest pbReleaseRequest = ReleaseRequest.newBuilder().setHeader(pbHeader)
                    .setConnectionId(connectionId).build();

            LOG.finer("Built protobuf message `ReleaseRequest`:\n" + pbReleaseRequest);
            ReleaseResponse pbReleaseResponse = connectionProviderStub
                    .release(pbReleaseRequest);
            // check the protobuf ReleaseResponse and either return a SOAP ServiceException or the generic Ack
            if (pbReleaseResponse.hasServiceException()) {
                addHeaders(soapHeader.value);
                throw new ServiceException(
                        pbReleaseResponse.getServiceException().getText(),
                        toSoap(pbReleaseResponse.getServiceException())
                );
            }
        } catch (ConverterException | StatusRuntimeException ex) {
            addHeaders(soapHeader.value);
            throw new ServiceException(
                    ex.toString(),
                    genericInternalServiceException(soapHeader.value.getProviderNSA(), connectionId, ex.toString())
            );
        }
    }

    public void reserveAbort(String connectionId, javax.xml.ws.Holder<CommonHeaderType> soapHeader) throws ServiceException {
        LOG.info(String.format("SOAP->gRPC reserveAbort from %s", soapHeader.value.getRequesterNSA()));
        LOG.fine(String.format("connection ID %s", connectionId));
        try {
            Header pbHeader = toProtobuf(soapHeader.value);
            ReserveAbortRequest pbReserveAbortRequest = ReserveAbortRequest.newBuilder().setHeader(pbHeader)
                    .setConnectionId(connectionId).build();

            LOG.finer("Built protobuf message `ReserveAbortRequest`:\n" + pbReserveAbortRequest);
            ReserveAbortResponse pbReserveAbortResponse = connectionProviderStub
                    .reserveAbort(pbReserveAbortRequest);
            // check the protobuf ReserveAbortResponse and either return a SOAP ServiceException or the generic Ack
            if (pbReserveAbortResponse.hasServiceException()) {
                addHeaders(soapHeader.value);
                throw new ServiceException(
                        pbReserveAbortResponse.getServiceException().getText(),
                        toSoap(pbReserveAbortResponse.getServiceException())
                );
            }
        } catch (ConverterException | StatusRuntimeException ex) {
            addHeaders(soapHeader.value);
            throw new ServiceException(
                    ex.toString(),
                    genericInternalServiceException(soapHeader.value.getProviderNSA(), connectionId, ex.toString())
            );
        }
    }

    @Generated(value = "org.apache.cxf.tools.wsdlto.WSDLToJava", date = "2020-04-27T16:21:07.875+02:00")
    public GenericAcknowledgmentType querySummary(QueryType querySummary, javax.xml.ws.Holder<CommonHeaderType> soapHeader) throws ServiceException {
        LOG.info(String.format("SOAP->gRPC querySummary from %s", soapHeader.value.getRequesterNSA()));
        for (String connectionId : querySummary.getConnectionId())
            LOG.fine(String.format("connection ID %s", connectionId));
        for (String globalReservationId : querySummary.getGlobalReservationId())
            LOG.fine(String.format("global reservation ID %s", globalReservationId));
        if (querySummary.getIfModifiedSince() != null)
            LOG.fine(String.format("if modified since %s", querySummary.getIfModifiedSince().format(DateTimeFormatter.ISO_OFFSET_DATE_TIME)));
        try {
            Header pbHeader = toProtobuf(soapHeader.value);
            QuerySummaryRequest.Builder pbQuerySummaryReguestBuilder = QuerySummaryRequest.newBuilder();
            pbQuerySummaryReguestBuilder.setHeader(pbHeader);
            if (querySummary.getIfModifiedSince() != null) {
                pbQuerySummaryReguestBuilder.setIfModifiedSince(Timestamps.parse(querySummary.getIfModifiedSince().format(DateTimeFormatter.ISO_OFFSET_DATE_TIME)));
            }
            pbQuerySummaryReguestBuilder.addAllConnectionId(querySummary.getConnectionId());
            pbQuerySummaryReguestBuilder.addAllGlobalReservationId(querySummary.getGlobalReservationId());
            LOG.finer("Built protobuf message `QuerySummaryRequest`:\n" + pbQuerySummaryReguestBuilder.build());
            QuerySummaryResponse pbQuerySummaryResponse = connectionProviderStub
                    .querySummary(pbQuerySummaryReguestBuilder.build());
            // check the protobuf QuerySummaryResponse and either return a SOAP ServiceException or the generic Ack
            if (pbQuerySummaryResponse.hasServiceException()) {
                addHeaders(soapHeader.value);
                throw new ServiceException(
                        pbQuerySummaryResponse.getServiceException().getText(),
                        toSoap(pbQuerySummaryResponse.getServiceException())
                );
            }
            GenericAcknowledgmentType _return = null;
            return _return;
        } catch (ConverterException | ParseException | StatusRuntimeException ex) {
            addHeaders(soapHeader.value);
            throw new ServiceException(
                    ex.toString(),
                    genericInternalServiceException(soapHeader.value.getProviderNSA(), null, ex.toString())
            );
        }
    }
    
    @Generated(value = "org.apache.cxf.tools.wsdlto.WSDLToJava", date = "2020-04-27T16:21:07.875+02:00")
    public void queryResult(String connectionId, Long startResultId, Long endResultId,
                            javax.xml.ws.Holder<CommonHeaderType> soapHeader) throws ServiceException {
        LOG.info(String.format("SOAP->gRPC queryResult from %s", soapHeader.value.getRequesterNSA()));
        LOG.fine(String.format("connection ID %s", connectionId));
        LOG.fine(String.format("start result ID %d", startResultId));
        LOG.fine(String.format("end restult ID %d", endResultId));
        // TODO: replace notImplementedServiceException with queryResult implementation
        var serviceException = notImplementedServiceException(soapHeader.value.getProviderNSA(), "queryResult");
        throw new ServiceException(serviceException.getText(), serviceException);
        // try {
        // } catch (java.lang.Exception ex) {
        //     addHeaders(soapHeader.value);
        //     throw new ServiceException(
        //             ex.toString(),
        //             genericInternalServiceException(soapHeader.value.getProviderNSA(), connectionId, ex.toString())
        //     );
        // }
    }

    @Generated(value = "org.apache.cxf.tools.wsdlto.WSDLToJava", date = "2020-04-27T16:21:07.875+02:00")
    public QueryNotificationConfirmedType queryNotificationSync(QueryNotificationType queryNotificationSync,
                                                                javax.xml.ws.Holder<CommonHeaderType> soapHeader) throws Error {
        LOG.info(String.format("SOAP->gRPC queryNotificationSync from %s", soapHeader.value.getRequesterNSA()));
        LOG.fine(String.format("connection ID %s, %d, %d", queryNotificationSync.getConnectionId(),
                queryNotificationSync.getStartNotificationId(), queryNotificationSync.getEndNotificationId()));
        // TODO: replace notImplementedError with queryNotificationSync implementation
        var error = notImplementedError(soapHeader.value.getProviderNSA(), "queryNotificationSync");
        throw new Error(error.getServiceException().getText(), error);
        // try {
        //     QueryNotificationConfirmedType _return = null;
        //     return _return;
        // } catch (java.lang.Exception ex) {
        //     addHeaders(soapHeader.value);
        //     throw new Error(
        //             ex.toString(),
        //             genericInternalError(soapHeader.value.getProviderNSA(), queryNotificationSync.getConnectionId(), ex.toString())
        //     );
        // }
    }

}
